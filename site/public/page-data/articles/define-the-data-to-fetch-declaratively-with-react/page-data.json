{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/articles/define-the-data-to-fetch-declaratively-with-react/","result":{"data":{"markdownRemark":{"html":"<p>Fetching data in Flux applications has always been a controversial point. Should it be handled inside the stores? Should we have asynchronous actions to get it?</p>\n<p>In the last React conference we knew <a href=\"http://facebook.github.io/react/blog/2015/02/20/introducing-relay-and-graphql.html\" target=\"_blank\">how Facebook fetches the data in their react applications</a>. Basically they <em>created </em>a language to compose fetch queries called <strong>GraphQL</strong>. Their servers understand GraphQL queries and return just the requested data.</p>\n<p>It is really interesting how they create the GraphQL queries. <strong>Every component define their data dependencies declaratively</strong>. Something like this:</p>\n<pre class=\"lang:js decode:true\">var FriendInfo = React.createClass({\r\n    statics: {\r\n        queries: {\r\n            user: function(){\r\n                return graphql `User { name, mutual_friends { count } }`;\r\n            }\r\n        }\r\n    },\r\n    render: function() { ... }\r\n});</pre>\n<p>Before the component is mounted, facebook app fetches the data that it needs and inject it as props, so <code>FriendInfo</code> can access to the user data just accessing to <code>this.props.user</code>. This is done automatically thanks to a framework that they created called <strong>Relay</strong>, no special development (actions, actionHandlers... ) is needed when creating a new component to fetch the needed data.</p>\n<p>GraphQL, Relay... sounds really complex, and they are not opensourced yet. Is it possible to have the same workflow nowadays with our current tools? Sure, let's make a small app that works this way:</p>\n<ul>\n<li><a href=\"http://development.react-declarative-fetching.divshot.io/\" target=\"_blank\">Here the app finished and working</a>.</li>\n<li><a href=\"https://github.com/arqex/react-declarative-fetching\" target=\"_blank\">Here its source code at github</a>.</li>\n</ul>\n<h3>What do we want?</h2>\r\nWe want to <strong>define data dependencies</strong> for the components <strong>declaratively</strong> and <strong>inside the components themselves</strong>, the same way that is done with Facebook's Relay.\n<p>Imagine we have a <code>Posts</code> component that lists all the posts in our blog. We need to fetch all the posts of the blog for our component, so it will be like this:</p>\n<pre class=\"lang:js decode:true\">var Posts = React.createClass({\r\n    statics: {\r\n        deps: function(){\r\n            return { posts: '/posts' };\r\n        }\r\n    },\r\n\r\n    render: function() {\r\n        return (\r\n            &lt;div className=\"postsPage\"&gt;\r\n                &lt;h2&gt;Posts&lt;/h2&gt;\r\n                &lt;Table rows={ this.props.posts } /&gt;\r\n            &lt;/div&gt;\r\n        );\r\n    }\r\n}</pre>\n<p>We have defined that the component will need the data from the API route <code>/posts</code>.  That data should be fetched automatically, so the component can access to it through <code>this.props.posts</code>.</p>\n<p>This declaration is inside a static method in the react component because it will be called before the component is mounted, Even before it is instantiated, so it is not possible to call <code>this</code> inside the method.</p>\n<p>Since we don't have a GraphQL server, we are going to use a REST API. You probably would prefer to create an abstraction for fetching your data models, and not to use URLs inside the components, but for the sake of the demo I will leave it like this, keeping it easy to understand.</p>\n<p>In every step, I will explain the tools I have used to make my development easier:</p>\n<ul>\n<li><a href=\"https://github.com/typicode/jsonplaceholder\" target=\"_blank\">jsonplaceholder</a> let us to build our test REST service in just 30 seconds.</li>\n<li><a href=\"https://github.com/arqex/react-json-table\" target=\"_blank\">react-json-table</a> will format the post list for us.</li>\n</ul>\n<h3>Reading component's dependencies</h2>\r\nDeclaring the dependencies is easy, but we need to read and fetch them before mounting the component. That's sounds much harder. For doing so our app will use <a href=\"https://github.com/rackt/react-router\" target=\"_blank\">react-router</a>, but it is possible to follow the same strategy using other wrappers.\n<p>The app will be navigable, every time the user navigates the URL will change and react-router will load a different component for every URL. When the router is loading the component, it is the perfect time to read, fetch and inject the dependencies.</p>\n<p>We will have routes to manage <em>posts</em> and <em>users</em>:</p>\n<pre class=\"lang:js decode:true\">var routes = (\r\n\t&lt;Route name=\"app\" path=\"/\" handler={ App } location=\"history\" &gt;\r\n\t\t&lt;DefaultRoute name=\"home\" handler={ Home } /&gt;\r\n\r\n\t\t&lt;Route name=\"posts\" path=\"/posts\" handler={ Posts } /&gt;\r\n\t\t&lt;Route name=\"post\" path=\"/post/:id\" handler={ Post } /&gt;\r\n\t\t&lt;Route name=\"users\" path=\"/users\" handler={ Users } /&gt;\r\n\t\t&lt;Route name=\"user\" path=\"/user/:id\" handler={ User } /&gt;\r\n\r\n    \t&lt;NotFoundRoute name=\"notfound\" handler={ Home } /&gt;\r\n\t&lt;/Route&gt;\r\n);</pre>\n<p>In case you are not familiar with react-router, the code above defines the routes for our application. The main route <code>/</code> is handled by the <code>App</code> component, and inside it, other components will be loaded depending on the current URL. For the route <code>/posts</code> the component <code>Post,</code> that we defined before, will be loaded inside <code>App</code>. Let's have a look at the <code>App</code>'s <code>render</code> method to understand how it works:</p>\n<pre class=\"lang:js decode:true\">var App = React.createClass({\r\n\tcontextTypes: {\r\n\t\t// Router available through this.context.router\r\n\t\trouter: React.PropTypes.func\r\n\t},\r\n\r\n\trender: function() {\r\n\t\treturn (\r\n\t\t\t&lt;div&gt;\r\n\t\t\t\t&lt;Header /&gt;\r\n\t\t\t\t&lt;div className=\"content wrapper\"&gt;\r\n\t\t\t\t\t&lt;RouteHandler /&gt;\r\n\t\t\t\t&lt;/div&gt;\r\n\t\t\t&lt;/div&gt;\r\n\t\t);\r\n\t}\r\n}</pre>\n<p><code>RouteHandler</code> is a component provided by react-router. It will display the component for the route that matches the current URL, if we visit the route <code>/posts</code> it will print the <code>Posts</code> component out, or if we are in <code>/users</code> it will show the <code>Users</code> component.</p>\n<p>Our tasks are clear in order to load the dependencies:</p>\n<ul>\r\n\t<li>Detect URL changes.</li>\r\n\t<li>Know what is the component that <code>RouteHandler</code> is going to show and check its dependencies.</li>\r\n\t<li>Fetch their dependencies and inject them into the component.</li>\r\n</ul>\r\nWe are going to add state to our <code>App</code> component to control this process:\r\n<pre class=\"lang:js decode:true\">var App = React.createClass({\r\n\tgetInitialState: function(){\r\n\t\treturn { \r\n\t\t\t// Last URL loaded\r\n\t\t\tcurrentPath: false, \r\n\t\t\t// Whenever it is fetching dependencies\r\n\t\t\tloadingDeps: false,\r\n\t\t\t// Fetched data for the current route component\r\n\t\t\thandlerDeps: {} \r\n\t\t};\r\n\t}, ...\r\n}</pre>\r\nWhen I introduced the <code>App</code> component before, I defined a <code>contextType</code> for the router. That makes the <code>router</code> object accessible inside the <code>App</code> component using <code>this.context.router</code> and, thanks to it, we can check if there has been route changes easily . We will check if there has been any URL change everytime that the <code>App</code> component updates:\r\n<pre class=\"lang:js decode:true\">// Inside App component....\r\n\tisURLChanged: function(){\r\n\t\treturn this.context.router.getCurrentPath() !== this.state.currentPath;\r\n\t},\r\n\tcomponentWillMount: function(){\r\n\t\tif( this.isURLChanged() ){\r\n\t\t\tthis.fetchDependencies();\r\n\t\t}\r\n\t},\r\n\tcomponentWillReceiveProps: function(){\r\n\t\tif( this.isURLChanged() ){\r\n\t\t\tthis.fetchDependencies();\r\n\t\t}\r\n\t}</pre>\r\nNow it is clear when we are going to fetch the dependencies, but we need to know what data to fetch and, to do so, we will need what is the component that <code>RouteHandler</code> will load.\n<p>The <code>router</code> object has the <code>getCurrentRoutes</code> method that return an Array with all the routes that matches the current URL. So if we visit <code>/posts</code>, <code>this.context.router.getCurrentRoutes()</code> will return something like <code>[{route:'app'},{route:'posts'}]</code>. Knowing this we can get what component, AKA route handler, will be loaded:</p>\n<pre class=\"lang:js decode:true\">// Inside App component\r\n\tgetRouteHandler: function(){\r\n\t\tvar currentRoutes = this.context.router.getCurrentRoutes(),\r\n\t\t\ti = 0,\r\n\t\t\thandler = currentRoutes[0]\r\n\t\t;\r\n\r\n\t\t// Find this component as route handler\r\n\t\twhile( currentRoutes[ i ].handler !== this.constructor )\r\n\t\t\ti++;\r\n\r\n\t\t// Return the next handler, our child\r\n\t\treturn currentRoutes[ i + 1 ].handler;\r\n\t},</pre>\n<p>Once we have the component that is going to be mounted, getting its dependencies is as easy as:</p>\n<pre class=\"lang:js decode:true\">// Inside App component\r\n\tfetchDependencies: function(){\r\n\t\tvar deps = this.getRouteHandler().deps();\r\n\t\t....\r\n\t}\r\n</pre>\n<p>That's all, we already know what data dependencies we need to fetch from the server. In this part the only tool we have introduced is <a href=\"https://github.com/rackt/react-router\" target=\"_blank\">react-router</a>, them most popular router implementation for react that handles the component load and manage browser history for us.</p>\n<h3>Fetching and injecting the data</h2>\r\nWe already have access to what data the component needs, but we still need to fetch it before the component is mounted. That's not possible with the current <code>App</code>'s render method, data fetching takes time and the component is mounted as soon as the URL changes, so we need to delay the mounting to wait for the data. Let's modify our render method to do so:\r\n<pre class=\"lang:js decode:true\">// Inside App component\r\n\trender: function() {\r\n\t\tvar handler = &lt;h1&gt;Loading...&lt;/h1&gt;;\n<pre><code>\tif( !this.state.loadingDeps )\r\n\t\thandler = React.createElement(RouteHandler, this.state.handlerDeps );\r\n\r\n\treturn (\r\n\t\t&#x26;lt;div&#x26;gt;\r\n\t\t\t&#x26;lt;Header /&#x26;gt;\r\n\t\t\t&#x26;lt;div className=\"content wrapper\"&#x26;gt;\r\n\t\t\t{ handler }\r\n\t\t\t&#x26;lt;/div&#x26;gt;\r\n\t\t&#x26;lt;/div&#x26;gt;\r\n\t);\r\n}&#x3C;/pre>\n</code></pre>\n<p>In the update we have created a cool <code>Loading...</code> message for whenever the data is being loaded instead of the <code>RouteHandler</code>. Whenever the data has been loaded we need to update <code>this.state.loadingDeps</code> and the <code>RouteHandler</code> can be mounted with its needed data already there.</p>\n<p>We are using <code>React.createElement</code> method ( <a href=\"https://facebook.github.io/react/docs/glossary.html\" target=\"_blank\">see how it works</a> ) instead of JSX to render the <code>RouteHandler</code>. This way we can pass all the props to it at once, instead of writing all the JSX tag attributes.</p>\n<p>Everything is set up just to fetch the data, so let's have a look at the <code>fetchDependencies</code> method that actually do that:</p>\n<pre class=\"lang:js decode:true\">// Inside App component\r\n\tfetchDependencies: function(){\r\n\t\t// We are going to refresh the dependencies\r\n\t\tthis.setState({ currentPath: currentPath, handlerDeps: {}  });\r\n\r\n\t\tvar handler = this.getRouteHandler();\r\n\t\t// If there is nothing to fetch return\r\n\t\tif( !handler || !handler.deps )\r\n\t\t\treturn;\r\n\r\n\t\t// We are going to fetch data\r\n\t\tthis.setState( { loadingDeps: true } );\r\n\r\n\t\tvar me = this,\r\n\t\t\trouter = this.context.router,\r\n\t\t\thandlerDeps = handler.deps( router.getCurrentParams(), router.getCurrentQuery() )\r\n\t\t;\r\n\r\n\t\tthis.fetch( handlerDeps )\r\n\t\t\t.then( function( deps ){\r\n\t\t\t\t// Update the deps to load the route handler\r\n\t\t\t\tme.setState({\r\n\t\t\t\t\tloadingDeps: false,\r\n\t\t\t\t\thandlerDeps: deps\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t\t.catch( function( err ){\r\n\t\t\t\tconsole.log( err.stack || err );\r\n\t\t\t})\r\n\t\t;\r\n\t}</pre>\n<p>First thing to notice is how the state of the <code>App</code> component is updated before start fetching, in order to display the <em>loading</em> message automatically while the user waits. As you can see, as soon as the data has been fetched, we set it in <code>state</code>'s <code>handlerDeps</code> and that will refresh the <code>App</code>, rendering the component with the data.</p>\n<p>Second, we are passing the current URL parameters and query to the static <code>deps</code> method:</p>\n<pre class=\"lang:js decode:true\">handlerDeps = handler.deps( router.getCurrentParams(), router.getCurrentQuery() )</pre>\n<p>That will let a component different show data depending on the current URL. In our app we have a route <code>/post/:id</code> handled by the <code>Post</code> component. That route has the id parameter, and <code>Post</code> should display the details of the post that has that id, so we pass all the current parameters and even the URL query to the <code>deps</code> method in order to let the <code>Post</code> component fetch the right data.</p>\n<p>Let's have a look at how the <code>Post</code> component uses the id URL parameter:</p>\n<pre class=\"lang:js decode:true\">var Post = React.createClass({\r\n\tstatics: {\r\n\t\tdeps: function( params, query ){\r\n\t\t\treturn { post: '/posts/' + params.id };\r\n\t\t}\r\n\t},\r\n\r\n\trender: function() {\r\n\t\tvar post = this.props.post;\r\n\t\treturn (\r\n\t\t\t&lt;div className=\"post\"&gt;\r\n\t\t\t\t&lt;h2&gt;{ post.title }&lt;/h2&gt;\r\n\t\t\t\t&lt;Json value={ post } /&gt;\r\n\t\t\t&lt;/div&gt;\r\n\t\t);\r\n\t}\r\n});</pre>\n<p>As you can see, it defines the REST endpoint to hit using the <code>id</code> parameter.</p>\n<p>The last interesting thing of <code>fetchDependencies</code> methods is that it is using promises to know when the data has been fetched. Devs don't like promises so much lately because they hide errors and they are not cancellable. In this case they are really handy, because promises let's us fetch data from an unknown number of endpoints at the same time. We really don't care how many requests we are going to do to get all the data, we can use methods like <code>all</code> from the <a href=\"https://github.com/kriskowal/q\" target=\"_blank\">Q</a> promise library to get the response of all of them when they are finished.</p>\n<p>For example, the <a href=\"http://development.react-declarative-fetching.divshot.io/user/5\" target=\"_blank\">User component</a> displays user's details and also the list of posts of this user. It needs to fetch data from two different REST endpoints:</p>\n<pre class=\"lang:js decode:true\">var User = React.createClass({\r\n\tstatics: {\r\n\t\tdeps: function( params ){\r\n\t\t\treturn {\r\n\t\t\t\tuser: '/users/' + params.id,\r\n\t\t\t\tposts: '/posts?userId=' + params.id\r\n\t\t\t};\r\n\t\t}\r\n\t},\r\n\r\n\trender: function() {\r\n\t\tvar user = this.props.user;\r\n\t\treturn (\r\n\t\t\t&lt;div className=\"user\"&gt;\r\n\t\t\t\t&lt;h2&gt;{ user.name }&lt;/h2&gt;\r\n\t\t\t\t&lt;Json value={ user } /&gt;\r\n\t\t\t\t&lt;h2 className=\"userPosts\"&gt;{ user.name }&amp;#39;s posts&lt;/h2&gt;\r\n\t\t\t\t&lt;Table rows={ this.props.posts } /&gt;\r\n\t\t\t&lt;/div&gt;\r\n\t\t);\r\n\t}\r\n});</pre>\n<p>Both sets of data are fetched at the same time thanks to promises and Q.</p>\n<p>In this part, the app uses useful libraries like:</p>\n<ul>\n<li><a href=\"https://github.com/arqex/react-json\" target=\"_blank\">react-json</a> is a cool component for editing JSON and creating forms that is still under development, but it has a lot of potential.</li>\n<li><a href=\"https://github.com/kriskowal/q\" target=\"_blank\">Q</a> give us a lot of tools for handling promises.</li>\n<li><a href=\"https://github.com/gre/qajax\" target=\"_blank\">qajax </a>is a library that make ajax requests returning promises.</li>\n</ul>\n<h3>What's next?</h2>\r\nWe already have the app running, was it hard?\n<ul>\n<li><a href=\"http://development.react-declarative-fetching.divshot.io/\" target=\"_blank\">Here the app finished and working</a>.</li>\n<li><a href=\"https://github.com/arqex/react-declarative-fetching\" target=\"_blank\">Here its source code at github</a>.</li>\n</ul>\n<p>This article doesn't intend to be really strict about how defining data dependencies must be done, it just shows that it is achievable and it will boost our productivity when creating components.</p>\n<p>In Facebook's conf they show that their Relay framework can fetch data for components deep in the component hierarchy, all at once, a really cool feature that is not explored in this article.</p>\n<p>Also, the approach explained in this article would make two components that request the same data at the same time receive two different copies of the data. If one updates the data, the other component would get out of sync. In frontends, it is important that when one entity is updated, all the components that depends on that entity get notified. I will tackle that matter in my next post, so stay tuned ;)</p>","frontmatter":{"date":"June 11, 2015","slug":"/articles/define-the-data-to-fetch-declaratively-with-react","title":"Define the data to fetch in a declarative way with React","type":"article"}}},"pageContext":{"id":"0d3415b5-8e73-5d66-9858-10a777acc13e","frontmatter__slug":"/articles/define-the-data-to-fetch-declaratively-with-react","__params":{"frontmatter__slug":"articles"}}},"staticQueryHashes":[]}