{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/articles/permanent-events-javascript/","result":{"data":{"markdownRemark":{"html":"<p>Events are old friends when we talk about javascript, and I think that I am not wrong if I say that you are not good at client javascript if you don't master how DOM events work. They are really helpful to handle the asynchronous nature of a web application, and that's why some libraries like jQuery and Backbone make an intensive use of custom events as a mechanism of communication among different parts of a web application.</p>\n<p>The most used event in jQuery is the 'document ready' one, and from my point of view that<em> ready type</em> of events are kind of special ones. Those events are triggered when some data turns available, and if you try to listen to those events after they have been triggered, you will wait forever, even if the data is already there to be used.</p>\n<p>That is not an unusal scenario when you load your files asynchronously, so, for some time, I have been using what I call <strong>permanent events</strong> to handle this problem.</p>\n<!--more-->\n<h3>Introducing permanent events</h2>\r\nWhat I needed was a kind of event that I can bind new listeners once it has been triggered, being sure that those listeners will be called. So something like following code would work great\r\n<pre class=\"lang:js decode:true\">object.trigger('ready');\r\nobject.on('ready', function(){\r\n\t// This will print 'It is ready' in the console\r\n\t// even if the listener has been added after the \r\n\t// event triggering.\r\n\tconsole.log('It is ready'); \r\n});</pre>\r\nThat means that, in the future, I can load new files and they will be able to ask safely if the object is ready just adding a listener to the event.\n<p>This behaviour is quite similar to <a title=\"Promises in ECMAScript 6\" href=\"http://www.html5rocks.com/en/tutorials/es6/promises/\" target=\"_blank\">the way the promises work</a>, once they are fulfilled any callback attached to them will be inmediately called. Using permanent events you can forget about promise objects and all the boilerplate code you need to handle them.</p>\n<p><em>Note: I think promises are great and permanent events aren't a general replacement for them, but an agile way of handling that 'data ready' situation.</em></p>\n<h3>Building permanent events for Backbone.js</h2>\r\nIf you are looking for using permanent events in Backbone I recommend to give a try to the <a title=\"Permanent events in backbone.js\" href=\"https://github.com/arqex/backbone-resolve\" target=\"_blank\">backbone-resolve plugin</a>, and you don't need to read anymore.\n<p>Are you still reading? Well, then I am forced to show how to create permanent events for Backbone.js. The same can be achieved for others libraries like jQuery following a similar approach.</p>\n<p>Instead of creating a Backbone plugin like backbone-resolve to extend Backbone's Event module directly, we are going to extend just one object to make it ready for permanent events. Let's call our object <code>PermanentEvents</code>, and we are going to implement a method in it called <code>resolve</code> (nod to promises) which is called instead of  <code>trigger</code> if we want to create a permanent event. An example would go as follows</p>\n<pre class=\"lang:js decode:true\">// First, extend our object with events\r\n// thanks to underscore\r\nvar myobject = _.extend({}, PermanentEvents);\r\n\r\n// trigger the permanent event 'ready'\r\nmyobject.resolve('ready', 'I am ready');\r\n\r\n// listening to the event now, \r\n// will execute the callback inmediatelly\r\nmyobject.on('ready', function(message){\r\n\t// Prints out 'I am ready'\r\n\tconsole.log(message);\r\n});</pre>\n<p>Of course, you could also add your listener before using the <code>resolve</code> function, and it will be called just after the event is resolved.</p>\n<p>Want to see how the resolve method work? Here it is.</p>\n<pre class=\"lang:js decode:true crayon-selected\">var PermanentEvents = _.({}, Backbone.Events);\r\n\r\nPermanentEvents.resolve = function(name){\r\n\t\t// make sure we have a resolved array\r\n\t\tthis._resolved || (this._resolved = {});\r\n\r\n\t\t// Any aditional parameter is used as argument for the callbacks\r\n\t\tvar parameters = Array.prototype.slice.call(arguments, 1);\r\n\r\n\t\t// Store the parameter values of the resolved event\r\n\t\tthis._resolved[name] = parameters;\r\n\r\n\t\t// Trigger the event to call any bound listener\r\n\t\treturn this.trigger.apply(this, arguments);\r\n\r\n}</pre>\n<p>Basically, <code>resolve</code> stores the events and any argument that needs to be passed to the listeners in a attribute called <code>_resolved</code>. Just after that, it calls Backbone.Events' <code>trigger</code> method, to execute any listener that may be bound already.</p>\n<p>With that code we have half of our work done. Now we just need to make the method <code>on</code> check if the events are already resolved to execute their listeners.</p>\n<pre class=\"lang:js decode:true\">PermanentEvents.on = function(name, callback, context){\r\n\t// If the event has been resolved, execute the callback\r\n\tif(this._resolved &amp;&amp; this._resolved[name])\r\n\t\tcallback.apply(context || this, this._resolved[name]);\r\n\r\n\t// And then continue as a standard on call, calling the original\r\n\t// on method\r\n\treturn Backbone.Events.on.apply(this, arguments);\r\n}</pre>\n<p>And that's all. It wasn't difficult, isn't it? You can extend any object with <code>PermanentEvents</code> in order to make it ready to resolve events. In Backbone's Events implementation, any function used to add listeners like <code>once</code>, <code>listenTo</code> or <code>listenToOnce</code> use the method <code>on</code> internally, so the code above is the only thing we need to make them all understand permanent events.</p>\n<p>Are you already using permanent events in your code? Drop a comment!</p>","frontmatter":{"date":"June 21, 2014","slug":"/articles/permanent-events-javascript","title":"Permanent events in javascript","type":"article"}}},"pageContext":{"id":"7c980fdc-7ad6-55c6-8d50-e3ec938190b2","frontmatter__slug":"/articles/permanent-events-javascript","__params":{"frontmatter__slug":"articles"}}},"staticQueryHashes":[]}