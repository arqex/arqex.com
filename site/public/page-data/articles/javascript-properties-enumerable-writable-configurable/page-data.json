{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/articles/javascript-properties-enumerable-writable-configurable/","result":{"data":{"markdownRemark":{"html":"<p>Objects are one of the main parts of Javascript. JS syntax for Objects is really concise and easy to use, so we are constantly creating objects and using them as hashmaps effortlessly.</p>\n<pre class=\"lang:js decode:true\">// My beloved object ob\r\nvar ob = {a: 1};\r\n\r\n// Accessing to a property\r\nob.a; // =&gt; 1\r\n\r\n// Modifying the value of a property\r\nob.a = 0;\r\nob.a; // =&gt; 0;\r\n\r\n// Creating a new property\r\nob.b = 2;\r\nob.b; // =&gt; 2\r\n\r\n// Deleting a property\r\ndelete ob.b;\r\nob.b; // =&gt; undefined</pre>\n<p>But, do you know that all the object properties in the example above are enumerable, writable and configurable? I mean:</p>\n<ul>\r\n\t<li><strong>Enumerable</strong>: I can access to all of them using a <code>for..in</code> loop. Also, enumerable property keys of an object are returned using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" target=\"_blank\"><code>Object.keys</code></a> method.</li>\r\n\t<li><strong>Writable</strong>: I can modify their values, I can update a property just assigning a new value to it: <code>ob.a = 1000</code>;</li>\r\n\t<li><strong>Configurable</strong>: I can modify the behavior of the property, so I can make them non-enumerable, non-writable or even non-cofigurable if I feel like doing so. Configurable properties are the only ones that can be removed using the <code>delete</code> operator.</li>\r\n</ul>\r\nI bet that you knew about the two first features of <code>Object</code>'s properties, but there are less developers that know that they can <strong>create and update them to be non-enumerable or immutable</strong> using the <code>Object</code>'s method called <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\">defineProperty</a>.\r\n<pre class=\"lang:js decode:true\">// Adding a property to ob using Object.defineProperty\r\nObject.defineProperty( ob, 'c', {\r\n  value: 3,\r\n  enumerable: false,\r\n  writable: false,\r\n  configurable: false\r\n});\n<p>ob.c; // => 3</p>\n<p>Object.getOwnPropertyDescriptor( ob, 'c' );\r\n// => {value: 3, enumerable: false, writable: false, configurable: false}</pre>\r\nI reckon that the syntax is not as friendly as usual one, but having this kind of properties can be really handy for some purposes. The object that define the property is called<strong> descriptor</strong>, and you can have a look at the descriptor of any property using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\" target=\"_blank\"><code>Object.getOwnPropertyDescriptor</code></a> method.</p>\n<p>It is funny that <strong>the default option values</strong> for <code>Object.defineProperty</code><strong> are completely the opposite</strong> to the ones applied when adding a property by assigment: The default property by assignment is non-enumerable, non-writable and non-configurable.</p>\n<pre class=\"lang:js decode:true\">// The 'f' property will be non-enumerable. non-writable and non-configurable\r\nObject.defineProperty( ob, 'f', {value: 6} );</pre>\n<p>It is also possible to define the properties on object creation if you instantiate it using the method <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Object/create\" target=\"_blank\"><code>Object.create( prototype, properties )</code></a>. It accepts an object with property descriptors as the second parameter, and it can be used as follows</p>\n<pre class=\"lang:js decode:true\">var ob = Object.create(Object.prototype, {\r\n  a: { writable:true, enumerable:true, value: 1 },\r\n  b: { enumerable: true, value: 2 }\r\n}});\r\n\r\nob; // =&gt; {a:1, b:2}</pre>\n<h3>Object's non-enumerable properties</h2>\r\nAs I said before, enumerable properties are accessible using <code>for...in</code> loops, so, non-enumerable ones aren't. Basically, non-enumerable properties won't be available using most of the functions that handle <code>Objects</code> as hashmaps.\r\n<ul>\r\n\t<li>They won't be in <code>for..in</code> iterations.</li>\r\n\t<li>They won't appear using <code>Object.keys</code> function.</li>\r\n\t<li>They are not serialized when using <code>JSON.stringify</code></li>\r\n</ul>\r\nSo they are kind of <em>secret</em> variables, but you can always access to them directly.\r\n<pre class=\"lang:default decode:true\">var ob = {a:1, b:2};\n<p>ob.c = 3;\r\nObject.defineProperty(ob, 'd', {\r\nvalue: 4,\r\nenumerable: false\r\n});</p>\n<p>ob.d; // => 4</p>\n<p>for( var key in ob ) console.log( ob[key] );\r\n// Console will print out\r\n// 1\r\n// 2\r\n// 3</p>\n<p>Object.keys( ob );  // => [\"a\", \"b\", \"c\"]</p>\n<p>JSON.stringify( ob ); // => \"{a:1,b:2,c:3}\"</p>\n<p>ob.d; // => 4</pre>\r\nSince this kind of properties are not serialized, I found them really useful when handling data model objects. I can add handy information to them using non enumerable properties.</p>\n<pre class=\"lang:js decode:true\">// Imagine the model that represent a car, it has a reference\r\n// to its owner using owner's id in the owner attribute\r\n\r\nvar car = {\r\n  id: 123,\r\n  color: red,\r\n  owner: 12\r\n};\r\n\r\n// I also have fetched the owner from the DB\r\n// Of course, the car is mine :)\r\nvar owner = {\r\n id: 12,\r\n name: Javi\r\n}\r\n\r\n// I can add the owner data to the car model\r\n// with a non-enumerable property, maybe it can\r\n// be useful in the future\r\nObject.defineProperty( car, 'ownerOb', {value: owner} );\r\n\r\n// I need the owner data now\r\ncar.ownerOb; // =&gt; {id:12, name:Javi}\r\n\r\n// But if I serialize the car object, I can't see me\r\nJSON.stringify( car ); // =&gt; '{id: 123, color: \"red\", owner: 12}'\r\n\r\n\r\n</pre>\n<p>Can you think how useful can this be to create a ORM library for example?</p>\n<p>In case that you need to know all properties in an object, enumerable and non-enumerable ones, the method <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\" target=\"_blank\"><code>Object.getOwnPropertyNames</code></a> returns an array with all the names.</p>\n<h3>Object's non-writable properties</h2>\r\nWhile the world waits for ES6 to finally arrive with the desired <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const\" target=\"_blank\"><code>const</code> statemen</a>t, non-writable properties are the <strong>most similar thing to a constant</strong> that we have in Javascript. Once its value is defined, <strong>it is not possible to change it using assignments</strong>.\r\n<pre class=\"lang:js decode:true\">var ob = {a: 1};\n<p>Object.defineProperty( ob, 'B', {value: 2, writable:false} );</p>\n<p>ob.B; // => 2</p>\n<p>ob.B = 10;</p>\n<p>ob.B; // => 2</pre>\r\nAs you can see, the assignment didn't affect the value of <code>ob.B</code> property. You need to be careful, because <strong>the assignment always returns the value assigned</strong>, even if the property is non-writable like the one in the example. In strict mode, trying to modifying a non-writable property would throw an <code>TypeError</code> exception:</p>\n<pre class=\"lang:js decode:true\">var ob = {a: 1};\r\nObject.defineProperty( ob, 'B', {value: 2, writable:false} );\r\n\r\n// Assingments returns the value\r\nob.B = 6; // =&gt; 6\r\nob.B = 1000; // =&gt; 1000\r\n\r\n// But the property remains the same\r\nob.B; =&gt; 2;\r\n\r\nfunction updateB(){\r\n  'use strict';\r\n  ob.B = 4; // This would throw an exception\r\n}\r\n\r\nupdateB(); // Throws the exception. I told you.\r\n</pre>\n<p>It is also needed to keep in mind that<strong> if the non-writable property contains an object</strong>, the reference to the object is what is not writable, but <strong>the object itself can be modified yet</strong>:</p>\n<pre class=\"lang:js decode:true\">var ob = {a: 1};\r\nObject.defineProperty( ob, 'OB', {value: {c:3}, writable:false} );\r\n\r\nob.OB.c = 4;\r\nob.OB.d = 5;\r\n\r\nob.OB; // =&gt; {c:4, d:5}\r\n\r\nob.OB = 'hola';\r\n\r\nob.OB; // =&gt; {c:4, d:5}</pre>\n<p>If you want to have a property with an completely non-writable object, you can use the function <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\"><code>Object.freeze</code></a>. <code>freeze</code> will make impossible to add, delete or update any object's property, and you will get a <code>TypeError</code> if you try so in strict mode.</p>\n<pre class=\"lang:js decode:true\">var ob = { a: 1, b: 2 };\r\n\r\nob.c = 3;\r\n\r\n// Freeze!\r\nObject.freeze( ob ); // =&gt; {a:1,b:2,c:3}\r\n\r\nob.d = 4;\r\nob.a = -10;\r\ndelete ob.b;\r\n\r\nObject.defineProperty( 'ob', 'e', {value: 5} );\r\n\r\n// Every modification was ignored\r\nob; // =&gt; {a:1,b:2,c:3}</pre>\n<h3>Object's non-configurable properties</h2>\r\nYou can update the previous behaviors of the properties if they are defined as configurable. You can use <code>defineProperty</code> once and again to change the property to writable or to non-enumerable. But once you have defined the property as non-configurable, there is only one behaviour you can change: If the property is writable, you can convert it to non-writable. Any other try of definition update will fail throwing a <code>TypeError</code>.\r\n<pre class=\"lang:js decode:true\">var ob = {};\r\nObject.defineProperty( ob, 'a', {configurable:false, writable:true} );\n<p>Object.defineProperty(ob, 'a', { enumerable: true }); // throws a TypeError\r\nObject.defineProperty(ob, 'a', { value: 12 }); // throws a TypeError\r\nObject.defineProperty(ob, 'a', { writable: false }); // This is allowed!!\r\nObject.defineProperty(ob, 'a', { writable: true }); // throws a TypeError\r\n</pre>\r\nAn important thing to know about the non-configurable properties is that they can't be removed from the object using the operator <code>delete</code>. So if you create a property non-configurable and non-writable you have a <em>frozen</em> property.</p>\n<pre class=\"lang:js decode:true\">var ob = {};\r\n\r\nObject.defineProperty( ob, 'a', {configurable: true, value: 1} );\r\n\r\nob; // =&gt; {a:1}\r\ndelete ob.a; // =&gt; true\r\nob; // =&gt; {}\r\n\r\nObject.defineProperty( ob, 'a', {configurable: false, value: 1} );\r\n\r\nob; // =&gt; {a:1}\r\ndelete ob.a; // =&gt; false\r\nob; // =&gt; {a:1}</pre>\n<h3>Conclusion</h2>\r\n<code>Object.defineProperty</code> was introduced with ES5, and you can start using it right now, <strong>it is supported by all modern browsers</strong>, including IE 9 ( and even IE 8, but <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Internet_Explorer_8_specific_notes\" target=\"_blank\">only for DOM objects</a> ). It is always fun to play with javascript basics in a different way that we are used to, and it is easy to learn new stuff just observing how javascript core objects work.\n<p><code>Object.defineProperty</code> also give us the chance of creating customized getters and setters for the properties, but I won't write about that today. If you want to learn more, have a look at the always amazing <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\">Mozilla's documentation</a>.</p>\n<p> </p>","frontmatter":{"date":"November 03, 2014","slug":"/articles/javascript-properties-enumerable-writable-configurable","title":"Javascript properties are enumerable, writable and configurable","type":"article"}}},"pageContext":{"id":"abc3e0d5-adbb-582e-a0d4-b6d5f699dcf3","frontmatter__slug":"/articles/javascript-properties-enumerable-writable-configurable","__params":{"frontmatter__slug":"articles"}}},"staticQueryHashes":[]}